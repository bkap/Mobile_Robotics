\documentclass{article}
\author{Connor Balin and Wesley Gould of team Delta}
\title{EECS 476 Midterm Report}
\date{3 March 2011}
\usepackage{fullpage}

\begin{document}
\maketitle

\section{Architecture Description}

\subsection{Goal Publisher}

The goal publisher's sole purpose is to publish goalPose.
It does not subscribe to anything, and at present the goal pose never changes.
Also, at present, even though the Path Planner listens to the Goal Publisher, it does not take its output into consideration except for deciding where on the path to stop.
It is hoped that in the future we will implement a path finding algorithm, rather than hard coding an initial path and inserting a swerve when we detect an obstacle.
When that happens, Goal Publisher's information will become more relevant.

\subsection{LIDAR Driver}

The LIDAR Driver was provided for us by the TA's.
It pulls LIDAR pings from the LIDAR sensor at a frequency of 75hz, transforms them into map coordinates and sends them to the LIDAR Mapper.
When it was given to us, it initially used the odom frame, but we decided that we would consistently use the map frame for all of our other nodes, so that we would be working in a consistent frame which could be debugged easily by looking at the map in stage.

\subsection{LIDAR Mapper}

The LIDARmapper subscribes to LIDARCloud and publishes LIDARMap, the fattened CSpace map.
The CSPace is returned as an OccupancyGrid with an origin at -10,-10 and height and width 35 in the map frame to contain the entire area of interest for this assignment.
The points in the point cloud are fattened by ORing a pre-generated template containing a disk of radius 15cm with the pixel containing the ping and its' neighbors.
Only pings within 10m of the robot are considered and only points for which the entirety of the fattened area would lie within the grid are added to the map.

\subsection{Path Planner}

The path planner subscribes to LIDARMap,PoseDes and goalPose and publishes pathList.
The planner has been pre-programmed for this demo with a path that it should be following unless it sees an obstacle with an A* search on the map hopefully forthcoming over break.
At present, the response to an obstruction in the path is a hardcoded pattern consisting of a swerve left followed by a swerve right once the path to the right is clear.
The swerve is always a fixed distance, and no further attempt to find obstacles is made during curves or swerves, so the current algorithm would likely crash if there were multiple nearby obstacles or if there were an obstacle in a curve or swerve.
In general, the Speed Profiler is still attmepting to search the current path for obstacles, so the robot should not hit any obstacles, but it may get stuck.
After generating the path, the Path Planner publishes the path as a PathList.

\subsection{Desired Path Crawler}

The Desired Path Crawler listens to the current speed put out by the Speed Profiler, and the PathList published by the Path Planner.
The Crawler moves a breadcrumb along the path published by the Path Planner at the speed that the Speed Profiler aledges we are moving.
It leaves the current speed blank so that the Speed Profiler can fill in what speed it would like to go.
After deciding a desired pose, the Desired Path Crawler publishes the desied path.

\subsection{Speed Profiler}

The Speed Profiler subscribes to the pose put out by the Desired Path Crawler, CSpace map published by the LIDAR Mapper, as well as the Path List put out by the Path Planner.
The Speed Profiler just fills in the linear speed at each point and republishes it with a different name, Speed Nominal.
It attempts to choose accelerate at the maximum allowed rate until it matches speed with what the Path Planner recommends in its PathList.
It is also looking to see if there are any obstacles in the current path, and will attempt to brake at the maximum safe rate to try to prevent immediate collisions.
The path planner is then expected to repath around obstacles.

\subsection{Steering Module}

The Steering Module subscribes to NominalSpeed and odom and publishes cmd_vel.
From NominalSpeed, the desired speed and pose are extracted for comparison with the actual pose from odom to generate steering corrections to return the robot to the desired path and schedule.
The corrections are performed by projecting the vector from desired pose to actual pose onto both the desired heading and a leftward normal to the desired heading to calculate following and lateral errors respectively.
This calculation is the same for both arcs and line segments, so the allowable path errors for good operation are less on an arc than for a line segment.
The steering correction on the arcs additionally feeds-forward the linear voloctiy correction to the angular velocity corrretion.
The corrections above nominal velocity are capped to .3 m / s for linear velocity and .5 rad / s for angular velocity and the total commanded linear velocity is constrained to be non-negative.

\section{Discussion}
\subsection{Observation of Performance}



\subsection{Bug Report}

We sometimes turn too early when attempting to swerve back after dodging an obstacle.
Planner tends to insert extra turns at the end of the path. We hope to fix this soon.

\subsection{Group Policies and Ideas for Improvement}

In general, our group has found it very useful to make use of version control systems and online backup, in particular, github.
We decided as a group that all positions will be in the map frame with the same origin across all nodes to reduce possible transform erros.
In addition, we found that OpenCV is rather convienent to use, and it is our opinion that we should replace all of the CSpace message types with OpenCV matrices or sparse matrices due to their convienence of use.


\end{document}
